package runtime

import (
	"strings"
	"testing"
	"fmt"
	
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/state"
	"github.com/ethereum/go-ethereum/core/vm"
	"github.com/ethereum/go-ethereum/ethdb"
)


/*
// based on https://github.com/ConsenSys/Project-Alchemy/blob/master/contracts/BLAKE2b/BLAKE2b.sol

// compiled with solc version:0.5.4+commit.9549d8ff.Emscripten.clang with optimizer enabled

pragma solidity ^0.5.1;

contract BLAKE2b {

  uint64 constant MASK_0 = 0xFF00000000000000;
  uint64 constant MASK_1 = 0x00FF000000000000;
  uint64 constant MASK_2 = 0x0000FF0000000000;
  uint64 constant MASK_3 = 0x000000FF00000000;
  uint64 constant MASK_4 = 0x00000000FF000000;
  uint64 constant MASK_5 = 0x0000000000FF0000;
  uint64 constant MASK_6 = 0x000000000000FF00;
  uint64 constant MASK_7 = 0x00000000000000FF;

  uint64 constant SHIFT_0 = 0x0100000000000000;
  uint64 constant SHIFT_1 = 0x0000010000000000;
  uint64 constant SHIFT_2 = 0x0000000001000000;
  uint64 constant SHIFT_3 = 0x0000000000000100;

  struct BLAKE2b_ctx {
    uint256[4] b; //input buffer
    uint64[8] h;  //chained state
    uint128 t; //total bytes
    uint64 c; //Size of b
    uint outlen; //diigest output size
  }

  // Mixing Function
  function G(uint64[16] memory v, uint a, uint b, uint c, uint d, uint64 x, uint64 y) private pure {

       // Dereference to decrease memory reads
       uint64 va = v[a];
       uint64 vb = v[b];
       uint64 vc = v[c];
       uint64 vd = v[d];

       //Optimised mixing function
       assembly{
         // v[a] := (v[a] + v[b] + x) mod 2**64
         va := addmod(add(va,vb),x, 0x10000000000000000)
         //v[d] := (v[d] ^ v[a]) >>> 32
         vd := xor(div(xor(vd,va), 0x100000000), mulmod(xor(vd, va),0x100000000, 0x10000000000000000))
         //v[c] := (v[c] + v[d])     mod 2**64
         vc := addmod(vc,vd, 0x10000000000000000)
         //v[b] := (v[b] ^ v[c]) >>> 24
         vb := xor(div(xor(vb,vc), 0x1000000), mulmod(xor(vb, vc),0x10000000000, 0x10000000000000000))
         // v[a] := (v[a] + v[b] + y) mod 2**64
         va := addmod(add(va,vb),y, 0x10000000000000000)
         //v[d] := (v[d] ^ v[a]) >>> 16
         vd := xor(div(xor(vd,va), 0x10000), mulmod(xor(vd, va),0x1000000000000, 0x10000000000000000))
         //v[c] := (v[c] + v[d])     mod 2**64
         vc := addmod(vc,vd, 0x10000000000000000)
         // v[b] := (v[b] ^ v[c]) >>> 63
         vb := xor(div(xor(vb,vc), 0x8000000000000000), mulmod(xor(vb, vc),0x2, 0x10000000000000000))
       }

       v[a] = va;
       v[b] = vb;
       v[c] = vc;
       v[d] = vd;
  }


  function compress(BLAKE2b_ctx memory ctx, bool last) private pure {
    //TODO: Look into storing these as uint256[4]
    uint64[16] memory v;
    uint64[16] memory m;

    uint64[8] memory IV = [
        0x6a09e667f3bcc908, 0xbb67ae8584caa73b,
        0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
        0x510e527fade682d1, 0x9b05688c2b3e6c1f,
        0x1f83d9abfb41bd6b, 0x5be0cd19137e2179
    ];


    for(uint i=0; i<8; i++){
      v[i] = ctx.h[i]; // v[:8] = h[:8]
      v[i+8] = IV[i];  // v[8:] = IV
    }

    //
    v[12] = v[12] ^ uint64(ctx.t % 2**64);  //Lower word of t
    v[13] = v[13] ^ uint64(ctx.t / 2**64);

    if(last) v[14] = ~v[14];   //Finalization flag

    uint64 mi;  //Temporary stack variable to decrease memory ops
    uint b; // Input buffer

    for(uint8 i = 0; i <16; i++){ //Operate 16 words at a time
      uint k = i%4; //Current buffer word
      mi = 0;
      if(k == 0){
        b=ctx.b[i/4];  //Load relevant input into buffer
      }

      //Extract relevent input from buffer
      assembly{
        mi := and(div(b,exp(2,mul(64,sub(3,k)))), 0xFFFFFFFFFFFFFFFF)
      }

      //Flip endianness
      m[i] = getWords(mi);
    }

    //Mix m

          G( v, 0, 4, 8, 12, m[0], m[1]);
          G( v, 1, 5, 9, 13, m[2], m[3]);
          G( v, 2, 6, 10, 14, m[4], m[5]);
          G( v, 3, 7, 11, 15, m[6], m[7]);
          G( v, 0, 5, 10, 15, m[8], m[9]);
          G( v, 1, 6, 11, 12, m[10], m[11]);
          G( v, 2, 7, 8, 13, m[12], m[13]);
          G( v, 3, 4, 9, 14, m[14], m[15]);


          G( v, 0, 4, 8, 12, m[14], m[10]);
          G( v, 1, 5, 9, 13, m[4], m[8]);
          G( v, 2, 6, 10, 14, m[9], m[15]);
          G( v, 3, 7, 11, 15, m[13], m[6]);
          G( v, 0, 5, 10, 15, m[1], m[12]);
          G( v, 1, 6, 11, 12, m[0], m[2]);
          G( v, 2, 7, 8, 13, m[11], m[7]);
          G( v, 3, 4, 9, 14, m[5], m[3]);


          G( v, 0, 4, 8, 12, m[11], m[8]);
          G( v, 1, 5, 9, 13, m[12], m[0]);
          G( v, 2, 6, 10, 14, m[5], m[2]);
          G( v, 3, 7, 11, 15, m[15], m[13]);
          G( v, 0, 5, 10, 15, m[10], m[14]);
          G( v, 1, 6, 11, 12, m[3], m[6]);
          G( v, 2, 7, 8, 13, m[7], m[1]);
          G( v, 3, 4, 9, 14, m[9], m[4]);


          G( v, 0, 4, 8, 12, m[7], m[9]);
          G( v, 1, 5, 9, 13, m[3], m[1]);
          G( v, 2, 6, 10, 14, m[13], m[12]);
          G( v, 3, 7, 11, 15, m[11], m[14]);
          G( v, 0, 5, 10, 15, m[2], m[6]);
          G( v, 1, 6, 11, 12, m[5], m[10]);
          G( v, 2, 7, 8, 13, m[4], m[0]);
          G( v, 3, 4, 9, 14, m[15], m[8]);


          G( v, 0, 4, 8, 12, m[9], m[0]);
          G( v, 1, 5, 9, 13, m[5], m[7]);
          G( v, 2, 6, 10, 14, m[2], m[4]);
          G( v, 3, 7, 11, 15, m[10], m[15]);
          G( v, 0, 5, 10, 15, m[14], m[1]);
          G( v, 1, 6, 11, 12, m[11], m[12]);
          G( v, 2, 7, 8, 13, m[6], m[8]);
          G( v, 3, 4, 9, 14, m[3], m[13]);


          G( v, 0, 4, 8, 12, m[2], m[12]);
          G( v, 1, 5, 9, 13, m[6], m[10]);
          G( v, 2, 6, 10, 14, m[0], m[11]);
          G( v, 3, 7, 11, 15, m[8], m[3]);
          G( v, 0, 5, 10, 15, m[4], m[13]);
          G( v, 1, 6, 11, 12, m[7], m[5]);
          G( v, 2, 7, 8, 13, m[15], m[14]);
          G( v, 3, 4, 9, 14, m[1], m[9]);


          G( v, 0, 4, 8, 12, m[12], m[5]);
          G( v, 1, 5, 9, 13, m[1], m[15]);
          G( v, 2, 6, 10, 14, m[14], m[13]);
          G( v, 3, 7, 11, 15, m[4], m[10]);
          G( v, 0, 5, 10, 15, m[0], m[7]);
          G( v, 1, 6, 11, 12, m[6], m[3]);
          G( v, 2, 7, 8, 13, m[9], m[2]);
          G( v, 3, 4, 9, 14, m[8], m[11]);


          G( v, 0, 4, 8, 12, m[13], m[11]);
          G( v, 1, 5, 9, 13, m[7], m[14]);
          G( v, 2, 6, 10, 14, m[12], m[1]);
          G( v, 3, 7, 11, 15, m[3], m[9]);
          G( v, 0, 5, 10, 15, m[5], m[0]);
          G( v, 1, 6, 11, 12, m[15], m[4]);
          G( v, 2, 7, 8, 13, m[8], m[6]);
          G( v, 3, 4, 9, 14, m[2], m[10]);


          G( v, 0, 4, 8, 12, m[6], m[15]);
          G( v, 1, 5, 9, 13, m[14], m[9]);
          G( v, 2, 6, 10, 14, m[11], m[3]);
          G( v, 3, 7, 11, 15, m[0], m[8]);
          G( v, 0, 5, 10, 15, m[12], m[2]);
          G( v, 1, 6, 11, 12, m[13], m[7]);
          G( v, 2, 7, 8, 13, m[1], m[4]);
          G( v, 3, 4, 9, 14, m[10], m[5]);


          G( v, 0, 4, 8, 12, m[10], m[2]);
          G( v, 1, 5, 9, 13, m[8], m[4]);
          G( v, 2, 6, 10, 14, m[7], m[6]);
          G( v, 3, 7, 11, 15, m[1], m[5]);
          G( v, 0, 5, 10, 15, m[15], m[11]);
          G( v, 1, 6, 11, 12, m[9], m[14]);
          G( v, 2, 7, 8, 13, m[3], m[12]);
          G( v, 3, 4, 9, 14, m[13], m[0]);


          G( v, 0, 4, 8, 12, m[0], m[1]);
          G( v, 1, 5, 9, 13, m[2], m[3]);
          G( v, 2, 6, 10, 14, m[4], m[5]);
          G( v, 3, 7, 11, 15, m[6], m[7]);
          G( v, 0, 5, 10, 15, m[8], m[9]);
          G( v, 1, 6, 11, 12, m[10], m[11]);
          G( v, 2, 7, 8, 13, m[12], m[13]);
          G( v, 3, 4, 9, 14, m[14], m[15]);


          G( v, 0, 4, 8, 12, m[14], m[10]);
          G( v, 1, 5, 9, 13, m[4], m[8]);
          G( v, 2, 6, 10, 14, m[9], m[15]);
          G( v, 3, 7, 11, 15, m[13], m[6]);
          G( v, 0, 5, 10, 15, m[1], m[12]);
          G( v, 1, 6, 11, 12, m[0], m[2]);
          G( v, 2, 7, 8, 13, m[11], m[7]);
          G( v, 3, 4, 9, 14, m[5], m[3]);



    //XOR current state with both halves of v
    for(uint8 i=0; i<8; ++i){
      ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i+8];
    }

  }


  function init(BLAKE2b_ctx memory ctx, uint64 outlen, bytes memory key, uint64[2] memory salt, uint64[2] memory person) private pure {

      if(outlen == 0 || outlen > 64 || key.length > 64) revert();

      uint64[8] memory IV = [
          0x6a09e667f3bcc908, 0xbb67ae8584caa73b,
          0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,
          0x510e527fade682d1, 0x9b05688c2b3e6c1f,
          0x1f83d9abfb41bd6b, 0x5be0cd19137e2179
      ];

      //Initialize chained-state to IV
      for(uint i = 0; i< 8; i++){
        ctx.h[i] = IV[i];
      }

      // Set up parameter block
      ctx.h[0] = ctx.h[0] ^ 0x01010000 ^ shift_left(uint64(key.length), 8) ^ outlen;
      ctx.h[4] = ctx.h[4] ^ salt[0];
      ctx.h[5] = ctx.h[5] ^ salt[1];
      ctx.h[6] = ctx.h[6] ^ person[0];
      ctx.h[7] = ctx.h[7] ^ person[1];

      ctx.outlen = outlen;
      uint64 i = uint64(key.length);

      //Run hash once with key as input
      if(i > 0){
        update(ctx, key);
        ctx.c = 128;
      }
  }


  function update(BLAKE2b_ctx memory ctx, bytes memory input) private pure {

    for(uint i = 0; i < input.length; i++){
      //If buffer is full, update byte counters and compress
      if(ctx.c == 128){
        ctx.t += ctx.c;
        compress(ctx, false);
        ctx.c = 0;
      }

      //Update temporary counter c
      uint c = ctx.c++;

      // b -> ctx.b
      uint256[4] memory b = ctx.b;
      uint8 a = uint8(input[i]);

      // ctx.b[c] = a
      assembly{
        mstore8(add(b,c),a)
      }
    }
  }


  function finalize(BLAKE2b_ctx memory ctx, uint64[8] memory out) private pure {
    // Add any uncounted bytes
    ctx.t += ctx.c;
    
    // zero out left over bytes (if key is longer than input)
    uint c = ctx.c++;
    uint8 a = 0;
    uint256[4] memory b = ctx.b;
    for(uint i = c; i < 128; i++) {
      // ctx.b[i] = 0
      assembly{
        mstore8(add(b,i),a)
      }
    }

    // Compress with finalization flag
    compress(ctx,true);

    //Flip little to big endian and store in output buffer
    for(uint i=0; i < ctx.outlen / 8; i++){
      out[i] = getWords(ctx.h[i]);
    }

    //Properly pad output if it doesn't fill a full word
    if(ctx.outlen < 64){
      out[ctx.outlen/8] = shift_right(getWords(ctx.h[ctx.outlen/8]),64-8*(ctx.outlen%8));
    }

  }

  //Helper function for full hash function
  function blake2b(bytes memory input, bytes memory key, bytes memory salt, bytes memory personalization, uint64 outlen) pure public returns(uint64[8] memory){

    BLAKE2b_ctx memory ctx;
    uint64[8] memory out;

    init(ctx, outlen, key, formatInput(salt), formatInput(personalization));
    update(ctx, input);
    finalize(ctx, out);
    return out;
  }

  function blake2b(bytes memory input, bytes memory key, uint64 outlen) pure public returns (uint64[8] memory){
    return blake2b(input, key, "", "", outlen);
  }

// Utility functions

  //Flips endianness of words
  function getWords(uint64 a) pure private returns (uint64 b) {
    return  (a & MASK_0) / SHIFT_0 ^
            (a & MASK_1) / SHIFT_1 ^
            (a & MASK_2) / SHIFT_2 ^
            (a & MASK_3) / SHIFT_3 ^
            (a & MASK_4) * SHIFT_3 ^
            (a & MASK_5) * SHIFT_2 ^
            (a & MASK_6) * SHIFT_1 ^
            (a & MASK_7) * SHIFT_0;
  }

  function shift_right(uint64 a, uint shift) pure private returns(uint64 b){
    return uint64(a / 2**shift);
  }

  function shift_left(uint64 a, uint shift) pure private returns(uint64){
    return uint64((a * 2**shift) % (2**64));
  }

  //bytes -> uint64[2]
  function formatInput(bytes memory input) pure private returns (uint64[2] memory output){
    for(uint i = 0; i<input.length; i++){
        //output[i/8] = output[i/8] ^ shift_left(uint64(input[i]), 64-8*(i%8+1));
        uint64 x;
        assembly {
            x := mload(add(input, add(0x08, i)))
        }
        output[i/8] = output[i/8] ^ shift_left(x, 64-8*(i%8+1));
    }
        output[0] = getWords(output[0]);
        output[1] = getWords(output[1]);
  }

  function formatOutput(uint64[8] memory input) pure private returns (bytes32[2] memory){
    bytes32[2] memory result;

    for(uint i = 0; i < 8; i++){
        result[i/4] = result[i/4] ^ bytes32(input[i] * 2**(64*(3-i%4)));
    }
    return result;
  }
}

*/




func BenchmarkBlake2b_plain(b *testing.B) {
	var definition = `[{"constant":true,"inputs":[{"name":"input","type":"bytes"},{"name":"key","type":"bytes"},{"name":"salt","type":"bytes"},{"name":"personalization","type":"bytes"},{"name":"outlen","type":"uint64"}],"name":"blake2b","outputs":[{"name":"","type":"uint64[8]"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":true,"inputs":[{"name":"input","type":"bytes"},{"name":"key","type":"bytes"},{"name":"outlen","type":"uint64"}],"name":"blake2b","outputs":[{"name":"","type":"uint64[8]"}],"payable":false,"stateMutability":"pure","type":"function"}]`

	var code = common.Hex2Bytes("608060405260043610610045577c010000000000000000000000000000000000000000000000000000000060003504631e092423811461004a578063d299dac0146102d7575b600080fd5b34801561005657600080fd5b5061029e600480360360a081101561006d57600080fd5b81019060208101813564010000000081111561008857600080fd5b82018360208201111561009a57600080fd5b803590602001918460018302840111640100000000831117156100bc57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929594936020810193503591505064010000000081111561010f57600080fd5b82018360208201111561012157600080fd5b8035906020019184600183028401116401000000008311171561014357600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929594936020810193503591505064010000000081111561019657600080fd5b8201836020820111156101a857600080fd5b803590602001918460018302840111640100000000831117156101ca57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929594936020810193503591505064010000000081111561021d57600080fd5b82018360208201111561022f57600080fd5b8035906020019184600183028401116401000000008311171561025157600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295505050903567ffffffffffffffff16915061041d9050565b604051808261010080838360005b838110156102c45781810151838201526020016102ac565b5050505090500191505060405180910390f35b3480156102e357600080fd5b5061029e600480360360608110156102fa57600080fd5b81019060208101813564010000000081111561031557600080fd5b82018360208201111561032757600080fd5b8035906020019184600183028401116401000000008311171561034957600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929594936020810193503591505064010000000081111561039c57600080fd5b8201836020820111156103ae57600080fd5b803590602001918460018302840111640100000000831117156103d057600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295505050903567ffffffffffffffff1691506104719050565b61042561161c565b61042d61163c565b61043561161c565b6104528285896104448a6104ae565b61044d8a6104ae565b61055f565b61045c8289610710565b61046682826107ed565b979650505050505050565b61047961161c565b6104a68484602060405190810160405280600081525060206040519081016040528060008152508661041d565b949350505050565b6104b6611679565b60005b8251811015610522576008818401810151906104e1908290840660010160080260400361091e565b8360088404600281106104f057fe5b60200201511883600884046002811061050557fe5b67ffffffffffffffff9092166020929092020152506001016104b9565b506105348160005b6020020151610932565b67ffffffffffffffff16815261054b81600161052a565b67ffffffffffffffff166020820152919050565b67ffffffffffffffff84161580610580575060408467ffffffffffffffff16115b8061058c575060408351115b1561059657600080fd5b61059e61161c565b506040805161010081018252676a09e667f3bcc908815267bb67ae8584caa73b6020820152673c6ef372fe94f82b9181019190915267a54ff53a5f1d36f1606082015267510e527fade682d16080820152679b05688c2b3e6c1f60a0820152671f83d9abfb41bd6b60c0820152675be0cd19137e217960e082015260005b60088110156106645781816008811061063157fe5b602002015187602001518260088110151561064857fe5b67ffffffffffffffff909216602092909202015260010161061c565b50846106728551600861091e565b60208881018051805167ffffffffffffffff94189490941863010100001883169093528551835160809081018051909218841690915286820151845160a0018051909118841690528551845160c00180519091188416905290850151925160e001805190931882169092528681169188019190915284519060009082161115610707576106ff8786610710565b608060608801525b50505050505050565b60005b81518110156107e857826060015167ffffffffffffffff166080141561077457606083015160408401805167ffffffffffffffff9092169091016fffffffffffffffffffffffffffffffff16905261076c8360006109b4565b600060608401525b60608301805167ffffffffffffffff60018201811690925216610795611694565b50835183516000908590859081106107a957fe5b01602001517f01000000000000000000000000000000000000000000000000000000000000009081900481020490508082840153505050600101610713565b505050565b60608201805160408401805167ffffffffffffffff8084169182016fffffffffffffffffffffffffffffffff169092526001909201169091526000610830611694565b508351825b608081101561084b578281830153600101610835565b506108578560016109b4565b60005b6080860151600890048110156108a657602086015161087e90826008811061052a57fe5b85826008811061088a57fe5b67ffffffffffffffff909216602092909202015260010161085a565b50604085608001511015610917576108ed6108da8660200151600888608001518115156108cf57fe5b046008811061052a57fe5b6080870151600716600802604003611450565b60808601518590600890046008811061090257fe5b67ffffffffffffffff90921660209290920201525b5050505050565b60020a67ffffffffffffffff918216021690565b600067010000000000000060ff8316026501000000000061ff00841602630100000062ff000085160261010063ff000000861681029064ff00000000871604630100000065ff00000000008816046501000000000066ff00000000000089160467010000000000000067ff000000000000008a16041818181818181892915050565b6109bc6116b3565b6109c46116b3565b6109cc61161c565b506040805161010081018252676a09e667f3bcc908815267bb67ae8584caa73b6020820152673c6ef372fe94f82b9181019190915267a54ff53a5f1d36f1606082015267510e527fade682d16080820152679b05688c2b3e6c1f60a0820152671f83d9abfb41bd6b60c0820152675be0cd19137e217960e082015260005b6008811015610ac45760208601518160088110610a6357fe5b6020020151848260108110610a7457fe5b67ffffffffffffffff9092166020929092020152818160088110610a9457fe5b6020020151846008830160108110610aa857fe5b67ffffffffffffffff9092166020929092020152600101610a4a565b506040850180516101808501805167ffffffffffffffff928316188216905290516101a085018051680100000000000000006fffffffffffffffffffffffffffffffff9093169290920490911890911690528315610b31576101c0830180511967ffffffffffffffff1690525b600080805b60108160ff161015610bbe576000925060038116801515610b71578851600460ff84160460ff16600481101515610b6957fe5b602002015192505b67ffffffffffffffff8160030360400260020a8404169350610b9284610932565b8660ff841660108110610ba157fe5b67ffffffffffffffff909216602092909202015250600101610b36565b50610be185600060046008600c89845b60200201518a60015b6020020151611472565b610bfe85600160056009600d8960025b60200201518a6003610bd7565b610c1b8560026006600a600e8960045b60200201518a6005610bd7565b610c388560036007600b600f8960065b60200201518a6007610bd7565b610c558560006005600a600f8960085b60200201518a6009610bd7565b610c728560016006600b600c89600a5b60200201518a600b610bd7565b610c8f85600260076008600d89600c5b60200201518a600d610bd7565b610cab85600360046009600e89815b60200201518a600f610bd7565b610cc885600060046008600c89600e5b60200201518a600a610bd7565b610ce585600160056009600d8960045b60200201518a6008610bd7565b610cf98560026006600a600e896009610c9e565b610d168560036007600b600f89600d5b60200201518a6006610bd7565b610d338560006005600a600f8960015b60200201518a600c610bd7565b610d508560016006600b600c8960005b60200201518a6002610bd7565b610d6485600260076008600d89600b610c2b565b610d7885600360046009600e896005610bf1565b610d8c85600060046008600c89600b610cd8565b610da985600160056009600d89600c5b60200201518a6000610bd7565b610dbd8560026006600a600e896005610d43565b610dd08560036007600b600f8981610c82565b610dec8560006005600a600f89825b60200201518a600e610bd7565b610e008560016006600b600c896003610d09565b610e1385600260076008600d8983610bce565b610e2f85600360046009600e89825b60200201518a6004610bd7565b610e4385600060046008600c896007610c48565b610e5785600160056009600d896003610bce565b610e6b8560026006600a600e89600d610d26565b610e7e8560036007600b600f8982610ddf565b610e928560006005600a600f896002610d09565b610ea68560016006600b600c896005610cbb565b610eba85600260076008600d896004610d9c565b610ece85600360046009600e89600f610cd8565b610ee285600060046008600c896009610d9c565b610ef585600160056009600d8983610c2b565b610f088560026006600a600e8984610e22565b610f1c8560036007600b600f89600a610c9e565b610f308560006005600a600f89600e610bce565b610f438560016006600b600c8982610d26565b610f5785600260076008600d896006610cd8565b610f6a85600360046009600e8984610c82565b610f7e85600060046008600c896002610d26565b610f9285600160056009600d896006610cbb565b610fa68560026006600a600e896000610c65565b610fba8560036007600b600f896008610bf1565b610fce8560006005600a600f896004610c82565b610fe28560016006600b600c896007610c0e565b610ff685600260076008600d89600f610ddf565b61100a85600360046009600e896001610c48565b61101d85600060046008600c8981610c0e565b61103085600160056009600d8984610c9e565b6110438560026006600a600e8981610c82565b6110578560036007600b600f896004610cbb565b61106a8560006005600a600f8984610c2b565b61107d8560016006600b600c8983610bf1565b61109185600260076008600d896009610d43565b6110a585600360046009600e896008610c65565b6110b985600060046008600c89600d610c65565b6110cd85600160056009600d896007610ddf565b6110e18560026006600a600e89600c610bce565b6110f48560036007600b600f8984610c48565b6111078560006005600a600f8983610d9c565b61111b8560016006600b600c89600f610e22565b61112e85600260076008600d8982610d09565b61114285600360046009600e896002610cbb565b61115685600060046008600c896006610c9e565b61116a85600160056009600d89600e610c48565b61117e8560026006600a600e89600b610bf1565b6111928560036007600b600f896000610cd8565b6111a68560006005600a600f89600c610d43565b6111ba8560016006600b600c89600d610c2b565b6111ce85600260076008600d896001610e22565b6111e285600360046009600e89600a610c0e565b6111f685600060046008600c89600a610d43565b61120a85600160056009600d896008610e22565b61121e8560026006600a600e896007610d09565b6112328560036007600b600f896001610c0e565b6112458560006005600a600f8981610c65565b6112598560016006600b600c896009610ddf565b61126d85600260076008600d896003610d26565b61128185600360046009600e89600d610d9c565b61129485600060046008600c8984610bce565b6112a885600160056009600d896002610bf1565b6112bc8560026006600a600e896004610c0e565b6112d08560036007600b600f896006610c2b565b6112e48560006005600a600f896008610c48565b6112f88560016006600b600c89600a610c65565b61130c85600260076008600d89600c610c82565b61131f85600360046009600e8981610c9e565b61133385600060046008600c89600e610cbb565b61134785600160056009600d896004610cd8565b61135b8560026006600a600e896009610c9e565b61136f8560036007600b600f89600d610d09565b6113838560006005600a600f896001610d26565b6113978560016006600b600c896000610d43565b6113ab85600260076008600d89600b610c2b565b6113bf85600360046009600e896005610bf1565b60005b60088160ff161015611446578560ff6008830116601081106113e057fe5b60200201518660ff8316601081106113f457fe5b602002015189602001518360ff1660088110151561140e57fe5b6020020151181888602001518260ff1660088110151561142a57fe5b67ffffffffffffffff90921660209290920201526001016113c2565b5050505050505050565b60008160020a8367ffffffffffffffff1681151561146a57fe5b049392505050565b600087876010811061148057fe5b60200201519050600088876010811061149557fe5b6020020151905060008987601081106114aa57fe5b6020020151905060008a87601081106114bf57fe5b60200201519050680100000000000000008684860108935068010000000000000000640100000000858318096401000000008583180418905068010000000000000000818308915068010000000000000000650100000000008385180963010000008385180418925068010000000000000000858486010893506801000000000000000066010000000000008583180962010000858318041890506801000000000000000081830891506801000000000000000060028385180967800000000000000083851804189250838b8b60108110151561159857fe5b67ffffffffffffffff9092166020929092020152828b8a601081106115b957fe5b67ffffffffffffffff9092166020929092020152818b89601081106115da57fe5b67ffffffffffffffff9092166020929092020152808b88601081106115fb57fe5b67ffffffffffffffff90921660209290920201525050505050505050505050565b610100604051908101604052806008906020820280388339509192915050565b6101e060405190810160405280611651611694565b815260200161165e61161c565b81526000602082018190526040820181905260609091015290565b60408051808201825290600290829080388339509192915050565b6080604051908101604052806004906020820280388339509192915050565b61020060405190810160405280601090602082028038833950919291505056fea165627a7a723058205ce3dcf8a38e14500505928704e477df0d8442659a541a92ee38ff9a90d701910029")

	abi, err := abi.JSON(strings.NewReader(definition))
	if err != nil {
		b.Fatal(err)
	}

	// test vectors: https://github.com/BLAKE2/BLAKE2/blob/master/testvectors/blake2b-kat.txt

	input := common.Hex2Bytes("{{input}}")
	expected := "{{expected}}"
	key := common.Hex2Bytes("")
	outlen := uint64(64)

	verifyinput, err := abi.Pack("blake2b", input, key, outlen)

	if err != nil {
		b.Fatal(err)
	}

	var cfg = new(Config)
	setDefaults(cfg)
	cfg.State, _ = state.New(common.Hash{}, state.NewDatabase(ethdb.NewMemDatabase()))

	var (
		address = common.BytesToAddress([]byte("contract"))
		vmenv   = NewEnv(cfg)
		sender  = vm.AccountRef(cfg.Origin)
	)

	cfg.State.CreateAccount(address)
	cfg.State.SetCode(address, code)

	var (
		ret  []byte
		exec_err  error
		leftOverGas uint64
	)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		ret, leftOverGas, exec_err = vmenv.Call(sender, address, verifyinput, cfg.GasLimit, cfg.Value)
	}
	b.StopTimer()

	gasUsed := cfg.GasLimit - leftOverGas

	if exec_err != nil {
		b.Error(exec_err)
		return
	}

	ret_hex := common.Bytes2Hex(ret)

  // 00000000000000000000000000000000000000000000000033d0825dddf7ada90000000000000000000000000000000000000000000000009b0e7e307104ad07000000000000000000000000000000000000000000000000ca9cfd9692214f1500000000000000000000000000000000000000000000000061356315e784f3e5000000000000000000000000000000000000000000000000a17e364ae9dbb14c000000000000000000000000000000000000000000000000b2036df932b77f4b000000000000000000000000000000000000000000000000292761365fb328de0000000000000000000000000000000000000000000000007afdc6d8998f5fc1
	returned_digest := ret_hex[48:64] + ret_hex[112:128] + ret_hex[176:192] + ret_hex[240:256] + ret_hex[304:320] + ret_hex[368:384] + ret_hex[432:448] + ret_hex[496:512]

	if returned_digest != expected {
		b.Error(fmt.Sprintf("Expected %v, got %v", expected, returned_digest))
		return
	}
	fmt.Println("gasUsed:", gasUsed)

}
